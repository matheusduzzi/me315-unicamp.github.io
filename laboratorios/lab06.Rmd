---
title: "SQLite"
author: "Benilton Carvalho, Guilherme Ludwig"
date: ""
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval=FALSE)
```

## SQLite

O **SQLite** é uma biblioteca embutida em um processo único que é autônomo, não necessita de servidor e exige zero de configuração. O código é de domínio público e seu uso é gratuito em qualquer tipo de utilização. Trata-se de um sistema SQL completo, capaz de utilizar múltiplas tabelas, índices, gatilhos e visões. Ele funciona, virtualmente, em qualquer plataforme (incluindo móveis) e pesa cerca de 600KB.

## Objetivos

Ao fim deste laboratório, você deverá ser capaz de:
- Conectar-se a um banco de dados do tipo SQLite utilizando o R como interface;
- Explorar quais são as tabelas disponíveis no referido banco de dados;
- Identificar quais são as colunas de uma dada tabela existente no banco de dados;
- Realizar pesquisas simples;
- Extrair registros do banco de dados e armazená-las em objetos do R;
- Realizar pesquisas mais complexas, utilizando `WHERE`, `GROUP BY`, `INNER JOIN`, `HAVING`, `LIMIT`, `DISTINCT` e `GLOB`.

## Recomendações Gerais

- Toda manipulação de dados deve ocorrer com verbos do pacote `dplyr`.
- O livro `R for Data Science` possui um excelente capítulo sobre *strings*.

## Atividade

1. Baixe o arquivo `disco.db` e armazene na variável `path` o caminho completo (pasta) na qual o arquivo foi gravado. Utilize o comando `file.path()` para combinar a variável `path` com o nome do arquivo (`disco.db`) e obter o nome do arquivo com seu respectivo caminho. Armazene este resultado na variável `fname`.

```{r q1}
path = '../dados'
fname = file.path(path, 'disco.db')
```

2. Utilizando o pacote `RSQLite`, conecte-se ao arquivo de banco de dados. Armazene a conexão na variável `conn`.

```{r q2}
library(RSQLite)
conn = dbConnect(SQLite(), fname)
```

3. Liste as tabelas existentes no banco de dados.

```{r q3}
dbListTables(conn)
```

4. Identifique os nomes de todas as colunas existentes na tabela `customers`.

```{r q4}
dbListFields(conn, 'customers')
```

5. Utilizando **apenas** `SQLite`, com o apoio do comando `dbGetQuery`, identifique quantos clientes estão atualmente cadastrados neste banco de dados.

```{r q5}
dbGetQuery(conn, 'SELECT COUNT(*) FROM customers')
```

6. Utilizando **apenas** `SQLite`, identifique o número de países diferentes em que moram os clientes encontrados acima.

```{r q6}
dbGetQuery(conn, 'SELECT COUNT(*) FROM (SELECT DISTINCT country FROM customers)')
```

7. Utilizando **apenas** `SQLite`, quantos clientes existem por país? A tabela resultante deve conter o nome do país e a respectiva contagem, além de ser ordenada de maneira decrescente pela referida contagem.

```{r q7}
dbGetQuery(conn, 'SELECT DISTINCT country, COUNT(*) FROM customers GROUP BY country ORDER BY COUNT(*) DESC')
```

8. Quais são os 5 países com mais clientes registrados? Use apenas `SQLite`.

```{r q8}
dbGetQuery(conn, 'SELECT DISTINCT country, COUNT(*) FROM customers GROUP BY country ORDER BY COUNT(*) DESC LIMIT 5')
```

9. Quais são os países registrados que possuem apenas 6 letras no nome?

```{r q9}
dbGetQuery(conn, "SELECT DISTINCT country FROM customers WHERE country GLOB '??????'")
```

10. Quais foram as músicas compradas por clientes brasileiros?

```{r q10}
## Veja que eh um SELECT de SELECT
## O SELECT interno identifica todas as invoices
## de clientes brasileiros
## O SELECT externo, por meio de INNER JOIN, identifica
## as musicas presentes nestas invoices
sql = paste("SELECT DISTINCT name FROM invoice_items",
            "INNER JOIN tracks ON tracks.trackid=invoice_items.trackid",
            "WHERE invoiceid IN",
            "(SELECT DISTINCT invoiceid FROM customers",
            "INNER JOIN invoices ON invoices.customerid=customers.customerid",
            "WHERE country='Brazil')")
dbGetQuery(conn, sql)
```

11. Desconecte do banco de dados.

```{r q11, echo=TRUE}
dbDisconnect(conn)
```
